/////////////////////////////////////////////////////////////////////////
//
// Â© University of Southampton IT Innovation Centre, 2017
//
// Copyright in this library belongs to the University of Southampton
// University Road, Highfield, Southampton, UK, SO17 1BJ
//
// This software may not be used, sold, licensed, transferred, copied
// or reproduced in whole or in part in any manner or form or in or
// on any media by any person other than in accordance with the terms
// of the Licence Agreement supplied with the software, or otherwise
// without the prior written consent of the copyright owners.
//
// This software is distributed WITHOUT ANY WARRANTY, without even the
// implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
// PURPOSE, except where stated in the Licence Agreement supplied with
// the software.
//
// Created By : Nikolay Stanchev
//
/////////////////////////////////////////////////////////////////////////
//
//  License : GNU Lesser General Public License, version 3
//
/////////////////////////////////////////////////////////////////////////

package uk.ac.soton.itinnovation.xifiinteroperability.guitool.editor.testgenerators;

import uk.ac.soton.itinnovation.xifiinteroperability.guitool.data.DataModel;
import uk.ac.soton.itinnovation.xifiinteroperability.guitool.data.Function;
import uk.ac.soton.itinnovation.xifiinteroperability.guitool.data.GraphNode;
import uk.ac.soton.itinnovation.xifiinteroperability.guitool.data.Guard;
import uk.ac.soton.itinnovation.xifiinteroperability.guitool.data.Message;
import uk.ac.soton.itinnovation.xifiinteroperability.modelframework.specification.XMLStateMachine;

/**
 * This class represents a test generator used to create an API test from some specification (Swagger, RAML, etc.)
 * 
 * @author ns17
 */
public abstract class AbstractTestGenerator {
    
    /**
     * the base endpoint for the swagger API
     */
    protected String baseUrl;
    
    /**
     * the generated model, built from the spec
     */
    protected final DataModel specModel;
    
    /**
     * the data model generated by the tool to test error handling
     */
    protected final DataModel errorModel;
    
    /**
     * the data model generated by the tool to test typical REST patterns
     */
    protected final DataModel patternModel;
    
    /**
     * the next available ID for the data model
     */
    protected int availableID = 0;
    
    /**
     * the next available label for the data model
     */
    protected int availableStateLabel = 0;
    
    /**
     * this method gets the next available ID
     * @return the current available ID + 1
     */
    protected String getNextID(){
        availableID += 1;
        return Integer.toString(availableID);
    }
    
    /**
     * this method gets the next available state label
     * @return next available label in format A{number}
     */
    protected String getNextLabel(){
        availableStateLabel += 1;
        return "A" + availableStateLabel;
    }
    
    /**
     * gets the built XML spec model
     * @return string representing the built model
     */
    public String getModel(){
        return specModel.getGraphXML();
    }
    
    /**
     * gets the model testing error handling
     * @return the XML representation of the model testing error handling
     */
    public String getErrorModel(){
        return errorModel.getGraphXML();
    }
    
    /**
     * gets the model testing REST patterns
     * @return the XML representation of the model testing REST patterns
     */
    public String getPatternModel() {
        return patternModel.getGraphXML();
    }
    
    
    /**
     * constructs the data models used in the test generation
     */
    public AbstractTestGenerator(){
        specModel = new DataModel();
        errorModel = new DataModel();
        patternModel = new DataModel();
    }
    
    /**
     * builds the data model for the given specification
     * @return true if the model was successfully built and false otherwise
     */
    public final boolean buildModel(){
        String id = getNextID();
        if (!this.generateServer(id, specModel) || !this.generateServer(id, errorModel) || !this.generateServer(id, patternModel)){
            return false;
        }
        
        if (!this.generateTriggeredEvents()){
            return false;
        }
                
        return true;
    }
    
        
    /**
     * generates a not existing event to check correct error handling
     * @param path the resource path to use
     * @param method the method to use (GET, POST, etc.)
     * @param dataType (XML, JSON, etc.)
     * @param lastTriggerID the last trigger node ID
     * @param errorCode the error code to test (e.g. '404')
     * @param isLastEvent true if this is the last event in the model
     * @return the ID of the last graph node that was generated
     */
    protected String generateErrorEvent (String path, String method, String dataType, String lastTriggerID, String errorCode, boolean isLastEvent){
        return generateErrorEvent(path, method, dataType, lastTriggerID, errorCode, isLastEvent, errorModel);
    }
    
    /**
     * generates a not existing event to check correct error handling
     * @param path the resource path to use
     * @param method the method to use (GET, POST, etc.)
     * @param dataType (XML, JSON, etc.)
     * @param lastTriggerID the last trigger node ID
     * @param errorCode the error code to test (e.g. '404')
     * @param isLastEvent true if this is the last event in the model
     * @param model the model to use
     * @return the ID of the last graph node that was generated
     */
    protected String generateErrorEvent(String path, String method, String dataType, 
            String lastTriggerID, String errorCode, boolean isLastEvent, DataModel model){
        if (path.startsWith("/")){
            path = path.replaceFirst("/", "");
        }
        
        // add the normal node 
        final String normalID = this.getNextID();
        model.addNode(normalID, this.getNextLabel(), XMLStateMachine.NORMAL_LABEL);
        
        // add the connection between the trigger node and the normal node
        final String triggerTransitionID = this.getNextID();
        final Message trigger = (Message) model.addConnection(triggerTransitionID, lastTriggerID, normalID);
        trigger.updateMessage(baseUrl, path, method, dataType, "");
        
        // add the end node, this could be an end node if the model is built, or trigger node which continues with the model
        final String endID = this.getNextID();
        if (isLastEvent){
            final GraphNode endNode = (GraphNode) model.addNode(endID, this.getNextLabel(), XMLStateMachine.END_LABEL);
            endNode.addEndStateData(true, "");
        }
        else {
            model.addNode(endID, this.getNextLabel(), XMLStateMachine.TRIGGER_LABEL);
        }
        
         final String guardTransitionID = this.getNextID();
         final Guard guard = (Guard) model.addConnection(guardTransitionID, normalID, endID);
         guard.addGuard(Function.FunctionType.Equals, "http.from", "component." + XMLStateMachine.INTERFACE_LABEL + ".address");
         guard.addGuard(Function.FunctionType.Equals, "http.code", errorCode);
         
         return endID;
    }
    
    /**
     * generates the server architecture node
     * @param serverID the id of the server
     * @param model the data model to use (error or spec model)
     * @return true if the server node was successfully built and false otherwise
     */
    protected abstract boolean generateServer(String serverID, DataModel model);
    
    /**
     * generates a series of trigger events to test the API methods
     * @return true if the events were successfully generated and false otherwise
     */
    protected abstract boolean generateTriggeredEvents();
    
    /**
     * reads an API specification and parses it to a java object, every instance of a test
     * generator should implement this method
     * 
     * @param path the local path or URL to the spec
     * @return a java object representing the parsed specification
     */
    public abstract Object readSpec(String path);
}
